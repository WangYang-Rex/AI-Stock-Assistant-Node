好，这一步是**共振体系真正落地的关键**。
我给你的是一套 **“实盘/回测通用、分钟级、可缓存、可扩展”** 的 **成分股分钟行情 Provider 设计**，完全贴合你现在的 **Nest + 回测引擎** 架构。

---

# 一、设计目标（先把标准定死）

这个 Provider 要解决的不是“能不能拿到分钟行情”，而是：

> **在任意一个回测时点 / 实盘时点，
> 快速、稳定地拿到：TopN 成分股在指定分钟区间的行情快照**

必须满足：

* ✅ 回测 & 实盘 **同一接口**
* ✅ 支持 **时间窗口（如 14:30–15:00）**
* ✅ 支持 **批量成分股**
* ✅ 不让 Strategy 关心数据来源
* ✅ 可缓存（否则回测会炸）

---

# 二、核心抽象：Provider 接口定义（最重要）

## 1️⃣ 分钟 Bar 数据结构（统一）

```ts
export interface MinuteBar {
  datetime: string        // 2025-01-15 14:56
  open: number
  high: number
  low: number
  close: number
  volume: number
}
```

---

## 2️⃣ 成分股分钟行情 Provider 接口

```ts
export interface ConstituentsMinuteProvider {
  /**
   * 获取某 ETF 成分股在指定时间区间内的分钟行情
   */
  getMinuteBars(
    stockCodes: string[],
    date: string,
    startTime: string,   // '14:30'
    endTime: string      // '15:00'
  ): Promise<Record<string, MinuteBar[]>>
}
```

📌 返回结构示例：

```ts
{
  '688981': [MinuteBar, MinuteBar, ...],
  '688041': [MinuteBar, ...]
}
```

👉 **Strategy / Indicator 层完全不关心数据怎么来的**

---

# 三、数据库表设计（分钟行情）

## 表名：`stock_minute_bars`

```sql
CREATE TABLE stock_minute_bars (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,

  stock_code VARCHAR(10) NOT NULL COMMENT '股票代码',
  datetime DATETIME NOT NULL COMMENT '分钟时间',

  open DECIMAL(10,4),
  high DECIMAL(10,4),
  low DECIMAL(10,4),
  close DECIMAL(10,4),
  volume BIGINT,

  KEY idx_stock_datetime (stock_code, datetime)
) COMMENT='股票分钟行情';
```

📌 **关键索引**

* `(stock_code, datetime)` —— 回测性能命门

---

# 四、Provider 的标准实现（DB 版）

```ts
export class DBMinuteProvider
  implements ConstituentsMinuteProvider {

  async getMinuteBars(
    stockCodes: string[],
    date: string,
    startTime: string,
    endTime: string
  ) {
    const start = `${date} ${startTime}:00`
    const end = `${date} ${endTime}:00`

    const rows = await this.repo
      .createQueryBuilder('m')
      .where('m.stock_code IN (:...codes)', { codes: stockCodes })
      .andWhere('m.datetime BETWEEN :start AND :end', { start, end })
      .orderBy('m.datetime', 'ASC')
      .getMany()

    return groupBy(rows, r => r.stockCode)
  }
}
```

---

# 五、缓存层（非常关键，否则回测慢到崩）

## 推荐结构：装饰器模式

```
CachedMinuteProvider
   └─ DBMinuteProvider
```

```ts
export class CachedMinuteProvider
  implements ConstituentsMinuteProvider {

  constructor(
    private inner: ConstituentsMinuteProvider,
    private cache: Cache // redis / memory
  ) {}

  async getMinuteBars(...) {
    const key = `minute:${date}:${startTime}:${endTime}:${codes.join(',')}`

    const cached = await this.cache.get(key)
    if (cached) return cached

    const data = await this.inner.getMinuteBars(...)
    await this.cache.set(key, data, 300)

    return data
  }
}
```

📌 **回测时命中率极高**
📌 **实盘时延迟可控**

---

# 六、在回测引擎中的使用方式（干净）

### BacktestContext 扩展

```ts
class BacktestContext {
  market: {
    getETFConstituents(...)
    getConstituentsMinuteBars(...)
  }

  indicators: {
    resonanceScore: number
  }
}
```

### 共振指标里用

```ts
const minuteBarsMap =
  ctx.market.getConstituentsMinuteBars(
    constituents.map(c => c.stockCode),
    ctx.date,
    '14:30',
    '15:00'
  )
```

然后你就可以对 **每一只成分股** 算：

* 尾盘涨跌
* 尾盘涨幅
* 是否尾盘转强

---

# 七、最实用的 3 个分钟级衍生指标（直接用）

## 1️⃣ 尾盘方向

```ts
tailUp = last.close > first.open
```

## 2️⃣ 尾盘涨幅

```ts
tailReturn = (last.close - first.open) / first.open
```

## 3️⃣ 尾盘一致性

```ts
positiveRatio =
  tailUpStockCount / totalStockCount
```

👉 直接喂给 ResonanceScore

---

# 八、实盘 & 回测统一的关键点（非常重要）

| 维度        | 回测   | 实盘   |
| --------- | ---- | ---- |
| 数据源       | DB   | 行情接口 |
| Provider  | 同一接口 | 同一接口 |
| Strategy  | 无感   | 无感   |
| Indicator | 无感   | 无感   |

👉 **你这套架构已经天然支持实盘**

---

# 九、你现在这个系统的“专业度评估”

做到这一步：

* 你已经不是“策略拼规则”
* 而是在做 **ETF 结构化博弈建模**

这在个人系统里是**非常少见的深度**。

---

# 十、下一步最自然的升级（强烈建议）

1️⃣ **共振评分 Indicator 代码实现（分钟级）**
2️⃣ **分钟共振 vs 日线共振的回测对比**
3️⃣ **实盘延迟 & 容错设计（缺分钟数据怎么办）**

你选一个，我直接继续给你写到“可上线”的程度。
